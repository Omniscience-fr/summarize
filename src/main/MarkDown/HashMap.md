###### HashMap内部实现
1. Map接口
    1. Map接口有两个类型参数，K和V，分别表示键(Key)和值(Value)的类型
    
    2. keySet()/values()/entrySet()有一个共同的特点，它们返回的都是视图，不是拷贝的值，基于返回值的修改会直接修改Map自身
    
2. HashMap实现  
    1. table是一个Entry类型的数组，其中的每个元素指向一个单向链表，链表中的每个节点表示一个键值对，Entry是一个内部类
    
    2. table的初始值为EMPTY_TABLE，是一个空表,当添加键值对后，table就不是空表了，它会随着键值对的添加进行扩展，扩展的策略类似于ArrayList，添加第一个元素时，默认分配的大小为16，不过，并不是size大于16时再进行扩展，下次什么时候扩展与threshold有关。
    
    3. threshold表示阈值，当键值对个数size大于等于threshold时考虑进行扩展。threshold是怎么算出来的呢？一般而言，threshold等于table.length乘以loadFactor，比如，如果table.length为16，loadFactor为0.75，则threshold为12。
    loadFactor是负载因子，表示整体上table被占用的程度，是一个浮点数，默认为0.75，可以通过构造方法进行修改。
    
    4. 键值对保存  
        1. 若是第一次保存，则先调用inflateTable()方法给table分配实际的空间，分配的过程如下：  
            1. 首先获取capacity的值，默认为16
            2. 然后通过math.min()方法，计算出（capacity*loadFactor）与（MAXIMUM_CAPACITY + 1）的最小值，并赋值给threshold，作为阈值，为后期扩容用
            3. 创建一个Entry数组，长度为capacity，并赋给table
            
        2. 检测key是否为null，在不为null时，计算key的hash值，过程如下：  
            1. 定义一个int类型的变量h，赋值为0
            2. 将变量h与key的hash值取异或，并重新赋值给变量h
            3. 再将h无符号右移20位(相当于处于除以20的2)，h无符号右移12位(相当于处于除以12的2)和h本身取异或，并重新赋值给变量h
            4. 最后将h无符号右移7位(相当于处于除以7的2)，h无符号右移4位(相当于处于除以4的2)和h本身取异或，并将二进制值返回
            
        3. 调用indexFor()方法，计算键值在table中的存放位置，过程如下：  
            1. 将key的hash值h与2的幂次方-1进行按位与运算，并返回
            2. key的hash值h与2的幂次方-1进行按位与运算相当于h与2的幂次方求模运算
        4. 找到保存位置之后，开始遍历这个单链表table[i],查找是否已有这个键，过程如下：  
            1. 首先比较hash值
            2. 若hash值相同，再使用equals方法进行比较  
           注：首先比较hash值，是因为hash值是整数，比较效率要比equals方法快很多
            3. 若是找到相同得到键，则将该键的值改变
            
        5. 若没有找到，则调用addEntry()方法在给定的位置添加一条，过程如下:
            1. 首先判断空间是否足够，若是不够，即大小即将超过前边计算的阈值，并且对应的table位置已经有键值对，
            则调用resize()方法对table进行拓展，拓展的长度为原本长度的两倍，过程如下：  
                1. 创建一个新的Entry数组，长度为原有Entry数组的两倍
                2. 将原有Entry数组中的元素，赋值给新的Entry数组
                3. 用新的数组长度，重新计算阈值
        6. 过程简化总结：
            1. 计算键的哈希值
            2. 根据哈希值得到保存位置（取模）
            3. 插到对应位置的链表头部或更新已有值
            4. 根据需要扩展table大小
            
    5. 根据键获取值
        1. 先判断key是否为空，若不为空，则调用getEntry()方法获取键值对的节点entry，过程如下：  
            1. 先判断size是否为0，若是则返回null
            2. 若size不为0，则判断key是否等于null，若是则返回0，若不是则返回key的hash值
            3. 根据hash找到table中对应的链表
            4. 遍历链表，通过hash值进行逐个比较
            5. 查看是否包含某个键，若包含则返回当前key，若不包含则返回null
            
    6. 总结
        HashMap内部有一个table数组，每一个table[i]都指向一个单链表，根据键存取值，根据键算出hash
    取模之后得到在table中存放的位置，然后操作该位置指向的单链表。
3. HashMap特点：  
    HashMap内部使用数组链表和hash的方式实现，特点如下：  
      1. 根据键保存和获取值的效率都很高，为O(1)，每个单向链表往往只有一个或少数几个节点，根据hash值就可以直接快速定位。
      2. HashMap中的键值对没有顺序，因为hash值是随机的。
    
    